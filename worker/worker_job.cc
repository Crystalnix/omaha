// Copyright 2007-2009 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ========================================================================
//
// TODO(omaha): The jobs are not being moved to the completed state in the
// cancel/shutdown case.
// Should be able to ASSERT1(job->job_state() == COMPLETED) in the worker
// destructor.
#include "omaha/worker/worker_job.h"

#include <windows.h>
#include <atlcom.h>
#include <cstring>
#include <vector>
#include "omaha/common/const_addresses.h"
#include "omaha/common/const_object_names.h"
#include "omaha/common/constants.h"
#include "omaha/common/debug.h"
#include "omaha/common/error.h"
#include "omaha/common/logging.h"
#include "omaha/common/omaha_version.h"
#include "omaha/common/scope_guard.h"
#include "omaha/common/sta_call.h"
#include "omaha/common/string.h"
#include "omaha/common/user_info.h"
#include "omaha/common/utils.h"
#include "omaha/common/vista_utils.h"
#include "omaha/goopdate/config_manager.h"
#include "omaha/goopdate/const_goopdate.h"
#include "omaha/goopdate/goopdate_utils.h"
#include "omaha/goopdate/goopdate_xml_parser.h"
#include "omaha/goopdate/request.h"
#include "omaha/goopdate/resource.h"
#include "omaha/goopdate/update_response_data.h"
#include "omaha/net/browser_request.h"
#include "omaha/net/cup_request.h"
#include "omaha/net/network_request.h"
#include "omaha/net/simple_request.h"
#include "omaha/worker/application_data.h"
#include "omaha/worker/application_manager.h"
#include "omaha/worker/download_manager.h"
#include "omaha/worker/install_manager.h"
#include "omaha/worker/job.h"
#include "omaha/worker/job_creator.h"
#include "omaha/worker/ping.h"
#include "omaha/worker/ping_utils.h"
#include "omaha/worker/worker_event_logger.h"
#include "omaha/worker/worker_job_strategy.h"
#include "omaha/worker/worker_metrics.h"

// Generated by MIDL in the "BUILD_MODE.OBJ_ROOT + SETTINGS.SUBDIR".
#include "goopdate/google_update_idl.h"

namespace omaha {

// job_observer can be NULL.
WorkerJob::WorkerJob(WorkerJobStrategy* strategy, JobObserver* job_observer)
    : is_canceled_(false),
      cur_job_(NULL),
      bundle_dl_size_(0),
      bundle_bytes_downloaded_(0),
      job_observer_(job_observer),
      no_jobs_completed_ping_sent_(false),
      error_code_(S_OK) {
  CORE_LOG(L2, (_T("[WorkerJob::WorkerJob]")));
  ASSERT1(strategy);
  strategy_.reset(strategy);
  strategy_->set_worker_job(this);

  is_machine_ = strategy_->is_machine();
  running_version_  = GetVersionString();

  const NetworkConfig::Session& session(NetworkConfig::Instance().session());

  // The network request used by the update checks that do not require
  // encryption.
  network_request_.reset(new NetworkRequest(session));
  network_request_->AddHttpRequest(new CupRequest(new SimpleRequest));
  network_request_->AddHttpRequest(new SimpleRequest);
  network_request_->AddHttpRequest(new CupRequest(new BrowserRequest));
  network_request_->set_num_retries(1);

  // The network request used by the encrypted update checks. For trusted tester
  // update requests, because the TT token is a secret but is sent in the clear,
  // we need https.
  network_request_encrypted_.reset(new NetworkRequest(session));
  network_request_encrypted_->AddHttpRequest(new SimpleRequest);
  network_request_encrypted_->AddHttpRequest(new BrowserRequest);
  network_request_encrypted_->set_num_retries(1);

  // TODO(omaha): consider providing a download directory where file is
  // to be downloaded. This directory should be know very early during the
  // execution of the program and transmited as a parameter to DownloadManager.
  download_manager_.reset(new DownloadManager(is_machine_));
  download_manager_->set_impersonation_token(session.impersonation_token);

  ping_.reset(new Ping());
}

WorkerJob::~WorkerJob() {
  CORE_LOG(L2, (_T("[WorkerJob::~WorkerJob]")));
  for (size_t i = 0; i < jobs_.size(); ++i) {
    delete jobs_[i];
  }
}

HRESULT BuildUninstallPing(bool is_machine, Request** uninstall_ping) {
  CORE_LOG(L2, (_T("[BuildUninstallPing]")));
  ASSERT1(uninstall_ping);

  AppManager app_manager(is_machine);
  ProductDataVector products;
  HRESULT hr = app_manager.GetUnRegisteredProducts(&products);
  if (FAILED(hr)) {
    CORE_LOG(LE, (_T("[GetUnRegisteredProducts failed 0x%08x]"), hr));
    return hr;
  }

  scoped_ptr<Request> request(new Request(is_machine));
  for (size_t i = 0; i < products.size(); ++i) {
    ProductData& product_data = products[i];
    ASSERT1(product_data.app_data().is_uninstalled());

    CORE_LOG(L2, (_T("[found uninstalled product][parent %s][app guid %s]"),
                  GuidToString(product_data.app_data().parent_app_guid()),
                  GuidToString(product_data.app_data().app_guid())));

    // TODO(omaha): Do we have uninstall pings for components?
    AppRequestData app_request_data(product_data.app_data());
    PingEvent ping_event(PingEvent::EVENT_UNINSTALL,
                         PingEvent::EVENT_RESULT_SUCCESS,
                         0,  // error code
                         0,  // extra code 1
                         product_data.app_data().previous_version());
    app_request_data.AddPingEvent(ping_event);
    AppRequest app_request(app_request_data);
    request->AddAppRequest(app_request);

    VERIFY1(SUCCEEDED(app_manager.RemoveClientState(product_data.app_data())));
  }

  *uninstall_ping = request.release();
  return S_OK;
}

HRESULT WorkerJob::DoProcess() {
  CORE_LOG(L2, (_T("[WorkerJob::DoProcess]")));

  ProductDataVector products;
  HRESULT hr = DoProcessInternal(&products);

  if (FAILED(hr)) {
    CString msg;
    switch (hr) {
      case GOOPDATE_E_APP_INSTALL_DISABLED_BY_POLICY:
        ASSERT1(!strategy_->first_disallowed_app_name().IsEmpty());
        msg.FormatMessage(IDS_APP_INSTALL_DISABLED_BY_GROUP_POLICY,
                          strategy_->first_disallowed_app_name());
        break;

      case GOOPDATE_E_APP_UPDATE_DISABLED_BY_POLICY:
      case GOOPDATE_E_APP_UPDATE_DISABLED_EULA_NOT_ACCEPTED:
      default:
        msg.FormatMessage(IDS_INSTALL_FAILED, hr);
        break;
    }
    ASSERT1(!msg.IsEmpty());
    JobCompletionStatus status = (hr == GOOPDATE_E_WORKER_CANCELLED) ?
                                 COMPLETION_CANCELLED :
                                 COMPLETION_ERROR;
    NotifyCompleted(status, hr, msg, products);
  }

  return hr;
}

HRESULT WorkerJob::DoProcessInternal(ProductDataVector* products) {
  CORE_LOG(L2, (_T("[WorkerJob::DoProcessInternal]")));
  ASSERT1(products);
  ASSERT1(strategy_.get());

  scoped_co_init init_com_apt(COINIT_MULTITHREADED);
  HRESULT hr(init_com_apt.hresult());
  if (FAILED(hr)) {
    CORE_LOG(LE, (_T("[init_com_apt failed][0x%08x]"), hr));
    return hr;
  }

  if (job_observer_) {
    job_observer_->SetEventSink(this);
    job_observer_->OnShow();
  }

  hr = strategy_->PreUpdateCheck(products);
  if (FAILED(hr)) {
    CORE_LOG(LE, (_T("[PreUpdateCheck failed][0x%08x]"), hr));
    return hr;
  }

  if (products->empty()) {
    OPT_LOG(L1, (_T("[No products to check updates for. Exiting.]")));
    // We should always have products in all cases except for updates.
    ASSERT1(strategy_->IsAutoUpdate());
    NotifyCompleted(COMPLETION_SUCCESS, S_OK, _T("No products!"), *products);
    return S_OK;
  }

  hr = strategy_->RemoveDisallowedApps(products);
  if (FAILED(hr)) {
    CORE_LOG(LE, (_T("[RemoveDisallowedApps failed][0x%08x]"), hr));
    return hr;
  }

  hr = strategy_->DoUpdateCheck(*products);
  if (FAILED(hr)) {
    CORE_LOG(LE, (_T("[DoUpdateCheck failed][0x%08x]"), hr));
    return hr;
  }

  hr = strategy_->PostUpdateCheck();
  if (FAILED(hr)) {
    CORE_LOG(LE, (_T("[PostUpdateCheck failed][0x%08x]"), hr));
    return hr;
  }

  hr = strategy_->ProcessApps();
  if (FAILED(hr)) {
    CORE_LOG(LE, (_T("[ProcessApps failed][0x%08x]"), hr));
    return hr;
  }

  return strategy_->PostInstall();
}

int WorkerJob::CalculateBundleSize() const {
  CORE_LOG(L2, (_T("[WorkerJob::CalculateBundleSize]")));
  int bundle_dl_size = 0;
  for (size_t i = 0; i < jobs_.size(); ++i) {
    bundle_dl_size += jobs_[i]->response_data().size();
  }
  return bundle_dl_size;
}

HRESULT WorkerJob::DownloadJobs() {
  CORE_LOG(L2, (_T("[WorkerJob::DownloadJobs]")));
  bundle_dl_size_ = CalculateBundleSize();

  // Download all jobs.
  for (size_t i = 0; i < jobs_.size(); ++i) {
    if (is_canceled_) {
      return GOOPDATE_E_WORKER_CANCELLED;
    }

    cur_job_ = jobs_[i];
    ASSERT1(cur_job_);

    if (cur_job_->job_state() != JOBSTATE_COMPLETED) {
      cur_job_->set_job_observer(this);
      HRESULT hr = cur_job_->Download(download_manager_.get());
      cur_job_->set_job_observer(NULL);
      cur_job_ = NULL;
      if (FAILED(hr)) {
        CORE_LOG(LE, (_T("[DownloadJob failed with 0x%08x]"), hr));
        continue;
      }
    }

    cur_job_ = NULL;
  }

  return S_OK;
}

HRESULT WorkerJob::InstallJobs() {
  CORE_LOG(L2, (_T("[WorkerJob::InstallJobs]")));
  // Install all jobs. We install the jobs in the reverse order, since we want
  // the primary job, which is the first in the list to be installed last.
  // The primary job can then perform user visible actions such as start
  // the application.
  Jobs::reverse_iterator iter = jobs_.rbegin();
  for (; iter != jobs_.rend(); ++iter) {
    if (is_canceled_) {
      return GOOPDATE_E_WORKER_CANCELLED;
    }

    cur_job_ = *iter;
    ASSERT1(cur_job_);

    if (cur_job_->job_state() != JOBSTATE_COMPLETED) {
      cur_job_->set_job_observer(this);
      HRESULT hr = cur_job_->Install();

      if (SUCCEEDED(hr)) {
        if (!::IsEqualGUID(kGoopdateGuid, cur_job_->app_data().app_guid()) &&
            strategy_->IsAutoUpdate()) {
            ++metric_worker_app_updates_succeeded;
        }
      }

      cur_job_->set_job_observer(NULL);
      if (FAILED(hr)) {
        cur_job_ = NULL;
        CORE_LOG(LE, (_T("[InstallJob failed with 0x%08x]"), hr));
        // The error is reported as necessary by Job::Install.
        continue;
      }
    }
    cur_job_ = NULL;
  }

  return S_OK;
}

void WorkerJob::CreateRequestFromProducts(
    const ProductDataVector& products,
    Request** request,
    bool* encrypt_connection) {
  CORE_LOG(L2, (_T("[WorkerJob::CreateRequestFromProducts]")));
  ASSERT1(request);
  ASSERT1(encrypt_connection);

  *encrypt_connection = false;
  scoped_ptr<Request> req(new Request(is_machine_));
  for (size_t i = 0; i < products.size(); ++i) {
    const ProductData& product_data = products[i];
    if (!product_data.app_data().tt_token().IsEmpty()) {
      *encrypt_connection = true;
    }
    AppRequestData app_request_data(product_data.app_data());
    AppRequest app_request(app_request_data);
    for (AppDataVector::const_iterator it = product_data.components_begin();
         it != product_data.components_end();
         ++it) {
      AppRequestData component_request_data(*it);
      app_request.AddComponentRequest(component_request_data);
    }
    req->AddAppRequest(app_request);
  }
  ASSERT1(products.size() == static_cast<size_t>(req->get_request_count()));

  *request = req.release();
}

// If the job is interactive the job will notify the UI.
// This method could be called multiple times, and thus needs to be idempotent.
void WorkerJob::NotifyCompleted(JobCompletionStatus status,
                                DWORD error,
                                const CString& text,
                                const ProductDataVector& products) {
  CORE_LOG(L2, (_T("[WorkerJob::NotifyCompleted][%d][0x%08x]"), status, error));
  ASSERT1(IsCompletionStatusSuccess(status) || !text.IsEmpty());

  if (IsCompletionStatusSuccess(status)) {
    ASSERT1(S_OK == error);
    error_code_ = S_OK;
  } else {
    error_code_ = error;
    ASSERT1(FAILED(error_code_));
    if (SUCCEEDED(error_code_)) {
      error_code_ = E_FAIL;
    }
  }

  CompletionInfo info(status, error, text);
  if (jobs_.empty()) {
    if (job_observer_) {
      job_observer_->OnComplete(IsCompletionStatusSuccess(status) ?
                                    COMPLETION_CODE_SUCCESS :
                                    COMPLETION_CODE_ERROR,
                                text,
                                error);
      if (!no_jobs_completed_ping_sent_) {
        const bool is_update = strategy_->IsUpdate();

        // This is a pretty big assumption, unfortunately hard to enforce in
        // the code: since the jobs are empty, it means that the server did
        // not respond with updates available. In the case of silent and
        // on demand updates, this is a not an error. There is no need to send
        // a completion ping in this case.
        if (is_update &&
            IsCompletionStatusSuccess(status) &&
            error == NOERROR) {
          return;
        }

        no_jobs_completed_ping_sent_ = true;
        HRESULT hr = ping_utils::SendCompletedPingsForAllProducts(
            products,
            is_machine_,
            is_update,
            info,
            ping_.get());
        if (FAILED(hr)) {
          CORE_LOG(LW, (_T("[SendCompletedPingsForAllProducts failed][0x%08x]"),
                        hr));
        }
      }
    }

    return;
  }

  // cur_job_->NotifyCompleted will eventually bubble back up to
  // WorkerJob::OnCompleted which will complete the rest of the jobs.
  if (cur_job_) {
    cur_job_->NotifyCompleted(info);
  } else {
    // If there is no current job, and we are being asked to complete, then we
    // set the primary application as the current job and complete it.
    ASSERT1(!jobs_.empty());
    cur_job_ = jobs_[0];
    cur_job_->set_job_observer(this);
    cur_job_->NotifyCompleted(info);
    cur_job_->set_job_observer(NULL);
    cur_job_ = NULL;
  }
}

// Does the following:
// * Performs some pre-processing on the AppData.
// * Converts Job to Request.
// * Converts Request into a post string.
// * Sends the post.
// * Parses the response.
// * Saves the result inside the job.
// * Performs post-processing on the AppData.
HRESULT WorkerJob::DoUpdateCheck(const ProductDataVector& products) {
  CORE_LOG(L2, (_T("[WorkerJob::DoUpdateCheck]")));

  if (!ConfigManager::Instance()->CanUseNetwork(is_machine_)) {
    CORE_LOG(L1, (_T("[Update check failed because network use prohibited]")));
    return GOOPDATE_E_CANNOT_USE_NETWORK;
  }

  const bool use_update_metrics = strategy_->IsUpdate();

  if (use_update_metrics) {
    ++metric_worker_update_check_total;
  }

  // Google Update setup has completed if necessary before this point.
  // This binary's version should be the installed version.
  CString installed_version;
  ASSERT1(SUCCEEDED(RegKey::GetValue(
      ConfigManager::Instance()->registry_update(is_machine_),
      kRegValueInstalledVersion,
      &installed_version)));
  ASSERT1(GetVersionString() == installed_version);

  ASSERT1(!products.empty());

  // Notify the UI that we've started.
  OnCheckingForUpdate();

  Request* request = NULL;
  bool encrypt_connection = false;
  CreateRequestFromProducts(products, &request, &encrypt_connection);
  ASSERT1(request);
  scoped_ptr<Request> req(request);

  // Serialize the request.
  // TODO(omaha): the request string can be serialized as UTF-8 to avoid
  // additional copying of the request buffer when sending.
  CString request_string;
  HRESULT hr = GoopdateXmlParser::GenerateRequest(*req.get(),
                                                  true,
                                                  &request_string);
  if (FAILED(hr)) {
    CString msg;
    msg.FormatMessage(IDS_INSTALL_FAILED, hr);
    NotifyCompleted(COMPLETION_ERROR, hr, msg, products);
    return hr;
  }
  ASSERT1(!request_string.IsEmpty());

  // Get the url to send to.
  CString update_url;
  hr = ConfigManager::Instance()->GetUpdateCheckUrl(&update_url);
  if (FAILED(hr)) {
    CString msg;
    msg.FormatMessage(IDS_INSTALL_FAILED, hr);
    NotifyCompleted(COMPLETION_ERROR, hr, msg, products);
    return hr;
  }

  if (is_canceled_) {
    return GOOPDATE_E_WORKER_CANCELLED;
  }

  // Send the network request.
  CORE_LOG(L2, (_T("[Sending update check...]")));
  std::vector<uint8> response_buffer;
  NetworkRequest* network_request = encrypt_connection ?
                                    network_request_encrypted_.get() :
                                    network_request_.get();
  ASSERT1(network_request);
  hr = network_request->PostString(update_url,
                                   request_string,
                                   &response_buffer);
  if (hr == OMAHA_NET_E_REQUEST_CANCELLED) {
    return hr;
  }
  if (FAILED(hr)) {
    goopdate_utils::AddNetworkRequestDataToEventLog(network_request, hr);

    if (strategy_->ShouldLaunchBrowserOnUpdateCheckError()) {
      const TCHAR* const kUpdateCheckSourceId = _T("updatecheck");
      CString url;
      HRESULT hres = goopdate_utils::BuildHttpGetString(
          kUrlMoreInformation,
          hr,
          0,
          0,
          GuidToString(products[0].app_data().app_guid()),
          running_version_,
          is_machine_,
          strategy_->language(),
          kUpdateCheckSourceId,
          &url);
      if (SUCCEEDED(hres)) {
        VERIFY1(SUCCEEDED(goopdate_utils::LaunchBrowser(BROWSER_DEFAULT, url)));
      } else {
        CORE_LOG(LW, (_T("[BuildHttpGetString failed][0x%08x]"), hres));
      }
    }

    CString msg;
    // Ignore the return value because the default message is what we want.
    goopdate_utils::FormatMessageForNetworkError(
          hr,
          products[0].app_data().display_name(),
          &msg);

    NotifyCompleted(COMPLETION_ERROR, hr, msg, products);
    return hr;
  }
  ASSERT1(network_request->http_status_code() == HTTP_STATUS_OK);

  // Parse the response.
  CString response(Utf8BufferToWideChar(response_buffer));
  CORE_LOG(L2, (_T("[Parse update check][%s]"), response));
  UpdateResponses responses;
  hr = GoopdateXmlParser::ParseManifestString(response, &responses);
  if (FAILED(hr)) {
    CString msg;
    msg.FormatMessage(IDS_INSTALL_FAILED, hr);
    NotifyCompleted(COMPLETION_ERROR, hr, msg, products);
    return hr;
  }
  ASSERT1(static_cast<size_t>(req->get_request_count()) == responses.size());

  hr = CreateJobs(false, responses, products);
  if (FAILED(hr)) {
    return hr;
  }

  if (use_update_metrics) {
    ++metric_worker_update_check_succeeded;
  }
  return S_OK;
}

HRESULT WorkerJob::CreateJobs(bool is_offline,
                              const UpdateResponses& responses,
                              const ProductDataVector& products) {
  ASSERT1(!products.empty());
  ASSERT1(is_offline == responses.empty());

  CString event_log_text;
  Request ping_request(is_machine_);
  JobCreator job_creator(is_machine_, strategy_->IsUpdate(), ping_.get());
  job_creator.set_is_auto_update(strategy_->IsAutoUpdate());
  job_creator.set_is_update_check_only(strategy_->IsUpdateCheckOnly());
  job_creator.set_fail_if_update_not_available(
      strategy_->ShouldFailOnUpdateNotAvailable());
  CompletionInfo completion_info;

  HRESULT hr(S_OK);
  if (is_offline) {
    CString offline_dir =
        is_machine_ ?
        ConfigManager::Instance()->GetMachineSecureOfflineStorageDir() :
        ConfigManager::Instance()->GetUserOfflineStorageDir();
    hr = job_creator.CreateOfflineJobs(offline_dir,
                                       products,
                                       &jobs_,
                                       &ping_request,
                                       &event_log_text,
                                       &completion_info);
  } else {
    hr = job_creator.CreateJobsFromResponses(responses,
                                             products,
                                             &jobs_,
                                             &ping_request,
                                             &event_log_text,
                                             &completion_info);
  }

  WriteUpdateCheckEvent(is_machine_, hr, event_log_text);

  // Send ping_request to the server to report results of job creation.
  if (ping_request.get_request_count() > 0) {
    ping_->SendPing(&ping_request);
  }

  if (FAILED(hr)) {
    NotifyCompleted(completion_info.status,
                    completion_info.error_code,
                    completion_info.text,
                    products);
    return hr;
  }

  for (size_t i = 0; i < jobs_.size(); ++i) {
    OnUpdateAvailable(jobs_[i]->response_data().version());
  }

  return S_OK;
}

HRESULT WorkerJob::CreateOfflineJobs(const ProductDataVector& products) {
  CORE_LOG(L2, (_T("[WorkerJob::CreateOfflineJobs]")));
  UpdateResponses responses;
  return CreateJobs(true, responses, products);
}

// ::InterlockedExchange is used to have a memory barrier and flush the caches.
HRESULT WorkerJob::Cancel() {
  CORE_LOG(L2, (_T("[WorkerJob::Cancel]")));
  ASSERT1(ping_.get());
  ::InterlockedExchange(&is_canceled_, true);

  VERIFY1(SUCCEEDED(network_request_->Cancel()));
  VERIFY1(SUCCEEDED(network_request_encrypted_->Cancel()));
  VERIFY1(SUCCEEDED(download_manager_->Cancel()));
  VERIFY1(SUCCEEDED(ping_->Cancel()));
  return S_OK;
}

void WorkerJob::CompleteAllNonCompletedJobs(JobCompletionStatus status,
                                            DWORD error,
                                            const CString& text) {
  CORE_LOG(L2, (_T("[WorkerJob::CompleteAllNonCompletedJobs]")));
  CompletionInfo info(status, error, text);
  for (size_t i = 0; i < jobs_.size(); ++i) {
    Job* job = jobs_[i];
    ASSERT1(job);

    if (cur_job_ != job && job->job_state() != JOBSTATE_COMPLETED) {
      job->NotifyCompleted(info);
    }
  }
}

// Observer interface implementation.
void WorkerJob::OnShow() {
  CORE_LOG(L2, (_T("[WorkerJob::OnShow]")));
  if (job_observer_) {
    job_observer_->OnShow();
  }
}

void WorkerJob::OnCheckingForUpdate() {
  CORE_LOG(L2, (_T("[WorkerJob::OnCheckingForUpdate]")));
  if (job_observer_) {
    job_observer_->OnCheckingForUpdate();
  }
}

void WorkerJob::OnUpdateAvailable(const TCHAR* version_string) {
  CORE_LOG(L2, (_T("[WorkerJob::OnUpdateAvailable]")));
  if (job_observer_) {
    job_observer_->OnUpdateAvailable(version_string);
  }
}

void WorkerJob::OnWaitingToDownload() {
  CORE_LOG(L2, (_T("[WorkerJob::OnWaitingToDownload]")));
  if (job_observer_) {
    job_observer_->OnWaitingToDownload();
  }
}

void WorkerJob::OnDownloading(int time_remaining_ms, int pos) {
  CORE_LOG(L2, (_T("[WorkerJob::OnDownloading %d %d]"),
                time_remaining_ms, pos));
  UNREFERENCED_PARAMETER(pos);
  ASSERT1(cur_job_);

  int bytes_dl = bundle_bytes_downloaded_ + cur_job_->bytes_downloaded();
  ASSERT1(bytes_dl <= bundle_dl_size_);
  if (cur_job_->bytes_total() != 0) {
    int expected_pos = static_cast<int>((
        static_cast<double>(cur_job_->bytes_downloaded()) /
         cur_job_->bytes_total()) * 100);
    ASSERT1(expected_pos == pos);
  }

  int total_pos = 0;
  if (bundle_dl_size_) {
    total_pos = static_cast<int>((static_cast<float>(bytes_dl) /
                                              bundle_dl_size_) * 100);
  }

  if (job_observer_) {
    job_observer_->OnDownloading(time_remaining_ms, total_pos);
  }
}

void WorkerJob::OnWaitingToInstall() {
  CORE_LOG(L2, (_T("[WorkerJob::OnWaitingToInstall]")));
  ASSERT1(cur_job_);
  bundle_bytes_downloaded_ += cur_job_->response_data().size();

  // We switch over to waiting for install only when all jobs are downloaded.
  if (cur_job_ == jobs_.back() && job_observer_) {
    job_observer_->OnWaitingToInstall();
  }
}

void WorkerJob::OnInstalling() {
  CORE_LOG(L2, (_T("[WorkerJob::OnInstalling]")));
  ASSERT1(cur_job_);

  if (cur_job_ == jobs_.back() && job_observer_) {
    job_observer_->OnInstalling();
  }
}

void WorkerJob::OnPause() {
  CORE_LOG(L2, (_T("[WorkerJob::OnPause]")));
  ASSERT1(cur_job_);

  if (cur_job_ == jobs_.front() && job_observer_) {
    job_observer_->OnPause();
  }
}

void WorkerJob::OnComplete(CompletionCodes code,
                           const TCHAR* text,
                           DWORD error_code) {
  CORE_LOG(L2, (_T("[WorkerJob::OnComplete][%d][0x%08x]"), code, error_code));
  ASSERT1(cur_job_);
  ASSERT1(!jobs_.empty());

  if (code == COMPLETION_CODE_ERROR) {
    if (IsCompletionInstallerError(cur_job_->info())) {
      error_code_ = GOOPDATEINSTALL_E_INSTALLER_FAILED;
    } else {
      error_code_ = error_code;
    }

    ASSERT1(FAILED(error_code_));
    if (SUCCEEDED(error_code_)) {
      error_code_ = E_FAIL;
    }
  } else {
    error_code_ = S_OK;
  }

  if (strategy_->IsAutoUpdate()) {
    // TODO(Omaha): Refactor this code for bundles etc. Maybe move to strategy.
    return;
  }

  Job* primary_job = jobs_[0];
  ASSERT1(primary_job);

  if (code == COMPLETION_CODE_ERROR) {
    CString msg = text;
    if (primary_job != cur_job_) {
      // If there is an error because of a non-primary job,
      // we need to change the error message to reflect this.
      msg.FormatMessage(IDS_BUNDLE_INSTALL_FAILED,
                        cur_job_->app_data().display_name(),
                        text);
    }
    if (job_observer_) {
      job_observer_->OnComplete(code, msg, error_code);
    }

    // We need to complete all the other jobs in the bundle, since one of the
    // jobs failed. The jobs that have completed thus far, will not be
    // altered, however the jobs from this point on will be completed with
    // COMPLETION_ERROR.
    CompleteAllNonCompletedJobs(COMPLETION_ERROR,
                                static_cast<DWORD>(GOOPDATE_E_BUNDLE_ERROR),
                                msg);

    return;
  }

  if (cur_job_ == primary_job && job_observer_) {
    // If we are dealing with the primary application and the result is a
    // success we need to complete the UI.
    job_observer_->OnComplete(code, text, error_code);
  }
}

void WorkerJob::SetEventSink(ProgressWndEvents* event_sink) {
  CORE_LOG(L2, (_T("[WorkerJob::SetEventSink]")));
  UNREFERENCED_PARAMETER(event_sink);
  return;
}

// ProgressWndEvents implementation.
void WorkerJob::DoPause() {
  ASSERT(false, (_T("Pause is not currently supported")));
}

void WorkerJob::DoResume() {
  ASSERT(false, (_T("Pause is not currently supported")));
}

void WorkerJob::DoClose() {
  CORE_LOG(L2, (_T("[WorkerJob::DoClose]")));
  Cancel();
}

void WorkerJob::DoRestartBrowsers() {
  CORE_LOG(L2, (_T("[WorkerJob::DoRestartBrowsers]")));
  ASSERT1(!jobs_.empty());
  Job* primary_job = jobs_[0];
  ASSERT1(primary_job);
  primary_job->RestartBrowsers();
}

void WorkerJob::DoReboot() {
  ASSERT(false, (_T("Reboot is not currently supported")));
}

void WorkerJob::DoLaunchBrowser(const CString& url) {
  CORE_LOG(L2, (_T("[WorkerJob::DoLaunchBrowser %s]"), url));
  if (jobs_.empty()) {
    VERIFY1(SUCCEEDED(goopdate_utils::LaunchBrowser(BROWSER_DEFAULT, url)));
  } else {
    Job* primary_job = jobs_[0];
    ASSERT1(primary_job);
    primary_job->LaunchBrowser(url);
  }
}

// job_observer can be NULL.
WorkerJob* WorkerJobFactory::CreateWorkerJob(bool is_machine,
                                             const CommandLineArgs& args,
                                             JobObserver* job_observer) {
  WorkerJobStrategy* strategy(NULL);
#pragma warning(push)
// C4061: enumerator 'xxx' in switch of enum 'yyy' is not explicitly handled by
// a case label.
#pragma warning(disable : 4061)

  switch (args.mode) {
    case COMMANDLINE_MODE_IG:
    case COMMANDLINE_MODE_HANDOFF_INSTALL:
      strategy = WorkerJobStrategyFactory::CreateInstallStrategy(is_machine,
                                                                 args,
                                                                 job_observer);
      break;
    case COMMANDLINE_MODE_UA:
      strategy =
          WorkerJobStrategyFactory::CreateUpdateAppsStrategy(is_machine, args);
      break;
    default:
      ASSERT(false, (_T("Invalid mode for a WorkerJob.")));
  }

#pragma warning(pop)

  return new WorkerJob(strategy, job_observer);
}

HRESULT WorkerJobFactory::CreateOnDemandWorkerJob(
    bool is_machine,
    bool is_update_check_only,
    const CString& lang,
    const GUID& guid,
    IJobObserver* observer,
    WorkerComWrapperShutdownCallBack* call_back,
    WorkerJob** worker_job) {
  ASSERT1(observer);
  ASSERT1(call_back);
  ASSERT1(worker_job);
  *worker_job = NULL;

  scoped_ptr<OnDemandUpdateStrategy> strategy;
  strategy.reset(WorkerJobStrategyFactory::CreateOnDemandStrategy(
      is_update_check_only,
      lang,
      is_machine));

  // TODO(omaha): Should all the stuff in Init really be in this class?
  HRESULT hr = strategy->Init(guid, observer, call_back);
  if (FAILED(hr)) {
    return hr;
  }

  *worker_job = new WorkerJob(strategy.release(), strategy->GetJobObserver());
  return S_OK;
}

}  // namespace omaha

